---
title: "R Notebook"
output:
  html_document: default
  html_notebook: default
---
Then I plot the data zones to look at all of them, just to double-check nothing else changed. (It looks like the only change was between 2012 and 2016).
```{r}
arransimd %>%
  ggplot() +
  geom_sf(aes(fill = DataZone)) +
  facet_wrap('year') +
  theme(legend.position="none") +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(), axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```

Now I need to import my data
In this case 'Code-Point Open - GB', already downloaded from https://www.ordnancesurvey.co.uk/opendatadownload/products.html. 
I've already selected the National Grid Reference square I needed and put on the desktop.
```{r}
## Import data
ka <- read.csv("alldata/ka.csv")
```

```{r}
arran20162 %>%
  ggplot() +
  geom_sf(aes(fill = DataZone)) +
  facet_wrap('year') +
  theme(legend.position="none") +
  theme(axis.text.x=element_text(angle=45, hjust = 1))
```


Fiddle about with it.
```{r}
## Print it if you like by inputting "ka".

## Summarise it
summary(ka)

## Find out classes
sapply(ka,class)

## Use this bit to check which columns had unique values
## E.g Positional_quality_indicator column
length(unique(ka$Positional_quality_indicator))
```

```{r}
arransubsect %>%
ggplot() +
  geom_sf(aes(fill = name)) +
  theme(axis.text.x=element_text(angle=45, hjust = 1))
```

Now I plot the entire grid reference square as co-ordinates.
```{r}
## Plot Postcodes as co-ordinates
ggplot(data = ka) +
  geom_point(mapping = aes(x = Eastings, y = Northings))
```

Now I subselect from the KA data.
Initially I had to do this by looking at the data which was organised alphabetically by postcode.
Since Arran all begins 'KA27' it means I could simply select out the rows containing Arran postcodes together.
```{r}
## Selecting columns
postcodecoord <- data.frame(ka$Postcode,ka$Eastings,ka$Northings)
## OR
postcodecoord <- ka[,c("Postcode","Eastings","Northings")]

## Selecting rows
Arran <- ka[c(6700:6896),c("Postcode","Eastings","Northings")]
```

Now I plot it. (With a few labels, etc)
```{r}
## Neater version
ggplot(data = Arran) +
  geom_point(mapping = aes(x = Eastings, y = Northings)) +
  ggtitle("Arran Postcodes") +
  labs(title = "Arran Postcodes", x = "Eastings", y = "Northings") +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r}
#Try to plot side-by-side
#Plot 2016
arran2016 %>%
  ggplot() +
  geom_sf(aes(fill = DataZone))

#Plot 2012
arran2012 %>%
  ggplot() +
  geom_sf(aes(fill = DataZone))
```

```{r}
#Plot 2016
p1 <- arran2016 %>%
  ggplot() +
  geom_sf(aes(fill = Percentile)) +
  ggtitle("2016")

#Plot 2012
p2 <- arran2012 %>%
  ggplot() +
  geom_sf(aes(fill = Percentile)) +
  ggtitle("2012")

#Plot 2009
p3 <- arran2009 %>%
  ggplot() +
  geom_sf(aes(fill = Percentile)) +
  ggtitle("2009")

#Plot 2006
p4 <- arran2006 %>%
  ggplot() +
  geom_sf(aes(fill = Percentile)) +
  ggtitle("2006")

#Plot 2004
p5 <- arran2004 %>%
  ggplot() +
  geom_sf(aes(fill = Percentile)) +
  ggtitle("2004")

#Plot 2004-2016 Together
multiplot(p1, p2, p3, p4, p5, cols=3)
```

not sure how to get this to work

```{r}
arransimd2 <- group_by(arransimd, DataZone)
```

```{r}
datazones  %>%
  ggplot() +
  geom_sf(aes(fill = Percentile)) +
  facet_wrap('year') +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

```{r}
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

Now I have to load up a new function.
```{r}
#Multiplot code
#Multiplot code
#http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

#Also works
```{r}
DZpostcodes2 <- simple.sf2[simple.sf2$row %in% DZ1postcodes[[1]], ] 
```

```{r}
DZ1 <- exampleshapes[1,]
over(DZ1, examplepoints, returnList = TRUE)
```
